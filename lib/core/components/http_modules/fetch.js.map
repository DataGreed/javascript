{"version":3,"sources":["core/components/http_modules/fetch.js"],"names":["_detectErrorCategory","err","code","PNNetworkIssuesCategory","status","hasOwnProperty","timeout","PNTimeoutCategory","response","badRequest","PNBadRequestCategory","forbidden","PNAccessDeniedCategory","PNUnknownCategory","_abstractedXDR","fetchUrl","method","endpoint","callback","body","fetchConfig","console","log","then","catch","error","createURL","origin","path","queryParams","base","Object","keys","length","map","encodeURIComponent","k","join","POST","url","GET"],"mappings":";;;;;;AAGA;;;;AAEA;;;;AAEA;;;;AAEA,IAAMA,uBAAuB,SAAvBA,oBAAuB,CAACC,GAAD,EAAyB;AACpD,MAAIA,IAAIC,IAAJ,KAAa,WAAjB,EAA8B,OAAO,qBAAkBC,uBAAzB;AAC9B,MAAIF,IAAIG,MAAJ,KAAe,CAAf,IAAqBH,IAAII,cAAJ,CAAmB,QAAnB,KAAgC,OAAOJ,IAAIG,MAAX,KAAsB,WAA/E,EAA6F,OAAO,qBAAkBD,uBAAzB;AAC7F,MAAIF,IAAIK,OAAR,EAAiB,OAAO,qBAAkBC,iBAAzB;;AAEjB,MAAIN,IAAIO,QAAR,EAAkB;AAChB,QAAIP,IAAIO,QAAJ,CAAaC,UAAjB,EAA6B,OAAO,qBAAkBC,oBAAzB;AAC7B,QAAIT,IAAIO,QAAJ,CAAaG,SAAjB,EAA4B,OAAO,qBAAkBC,sBAAzB;AAC7B;;AAED,SAAO,qBAAkBC,iBAAzB;AACD,CAXD;;AAaA,IAAMC,iBAAiB,SAAjBA,cAAiB,OAA2D;AAAA,MAAxDC,QAAwD,QAAxDA,QAAwD;AAAA,MAA9CC,MAA8C,QAA9CA,MAA8C;AAAA,MAAtCC,QAAsC,QAAtCA,QAAsC;AAAA,MAA5BC,QAA4B,QAA5BA,QAA4B;AAAA,MAAlBC,IAAkB,QAAlBA,IAAkB;;AAChF,MAAMC,cAAc;AAClBJ,kBADkB;AAElBV,aAASW,SAASX;AAFA,GAApB;;AAKAe,UAAQC,GAAR,CAAY,EAAEP,kBAAF,EAAYK,wBAAZ,EAAZ;;AAEA,2BAAUL,QAAV,EAAoBK,WAApB,EACGG,IADH,CACQ,UAACf,QAAD,EAAc;AAClBa,YAAQC,GAAR,CAAYd,QAAZ;AACD,GAHH,EAIGgB,KAJH,CAIS,UAACC,KAAD,EAAW;AAChBJ,YAAQC,GAAR,CAAYG,KAAZ;AACD,GANH;AAmCD,CA3CD;;AA6CA,IAAMC,YAAY,SAAZA,SAAY,CAACC,MAAD,EAASC,IAAT,EAAeC,WAAf,EAA+B;AAC/C,MAAIC,OAAOH,SAASC,IAApB;;AAEA,MAAIC,eAAeE,OAAOC,IAAP,CAAYH,WAAZ,EAAyBI,MAAzB,GAAkC,CAArD,EAAwD;AACtDH,YAAQ,MAAMC,OAAOC,IAAP,CAAYH,WAAZ,EAAyBK,GAAzB,CAA6B;AAAA,aAAKC,mBAAmBC,CAAnB,IAAwB,GAAxB,GAA8BD,mBAAmBN,YAAYO,CAAZ,CAAnB,CAAnC;AAAA,KAA7B,EAAoGC,IAApG,CAAyG,GAAzG,CAAd;AACD;;AAED,SAAOP,IAAP;AACD,CARD;;kBAUe;AACbQ,QAAM,qBAA0D;AAAA,QAAvDT,WAAuD,SAAvDA,WAAuD;AAAA,QAA1CV,IAA0C,SAA1CA,IAA0C;AAAA,QAApCF,QAAoC,SAApCA,QAAoC;AAAA,QAA1BC,QAA0B,SAA1BA,QAA0B;;AAC9D,QAAMH,WAAWW,UAAUT,SAASU,MAAnB,EAA2BV,SAASsB,GAApC,EAAyCV,WAAzC,CAAjB;AACA,WAAOf,eAAe,EAAEC,kBAAF,EAAYC,QAAQ,KAApB,EAA2BC,kBAA3B,EAAqCC,kBAArC,EAA+CC,UAA/C,EAAf,CAAP;AACD,GAJY;;AAMbqB,OAAK,oBAAoD;AAAA,QAAjDX,WAAiD,SAAjDA,WAAiD;AAAA,QAApCZ,QAAoC,SAApCA,QAAoC;AAAA,QAA1BC,QAA0B,SAA1BA,QAA0B;;AACvD,QAAMH,WAAWW,UAAUT,SAASU,MAAnB,EAA2BV,SAASsB,GAApC,EAAyCV,WAAzC,CAAjB;AACA,WAAOf,eAAe,EAAEC,kBAAF,EAAYC,QAAQ,MAApB,EAA4BC,kBAA5B,EAAsCC,kBAAtC,EAAf,CAAP;AACD;AATY,C","file":"fetch.js","sourcesContent":["/* @flow */\n/* global window */\n\nimport nodeFetch from 'node-fetch';\n\nimport categoryConstants from '../../constants/categories';\n\nimport { EndpointDefinition, StatusAnnouncement } from '../../flow_interfaces';\n\nconst _detectErrorCategory = (err: Object): string => {\n  if (err.code === 'ENOTFOUND') return categoryConstants.PNNetworkIssuesCategory;\n  if (err.status === 0 || (err.hasOwnProperty('status') && typeof err.status === 'undefined')) return categoryConstants.PNNetworkIssuesCategory;\n  if (err.timeout) return categoryConstants.PNTimeoutCategory;\n\n  if (err.response) {\n    if (err.response.badRequest) return categoryConstants.PNBadRequestCategory;\n    if (err.response.forbidden) return categoryConstants.PNAccessDeniedCategory;\n  }\n\n  return categoryConstants.PNUnknownCategory;\n};\n\nconst _abstractedXDR = ({ fetchUrl, method, endpoint, callback, body}): Object => {\n  const fetchConfig = {\n    method,\n    timeout: endpoint.timeout\n  };\n\n  console.log({ fetchUrl, fetchConfig });\n\n  nodeFetch(fetchUrl, fetchConfig)\n    .then((response) => {\n      console.log(response);\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n\n  // attach a logger\n  // if (endpoint.isDebug) {\n  //   superagentConstruct = superagentConstruct.use(_attachSuperagentLogger);\n  // }\n\n  /*\n  return superagentConstruct\n    .timeout(endpoint.timeout)\n    .end((err, resp) => {\n      let status: StatusAnnouncement = {};\n      status.error = err !== null;\n      status.operation = endpoint.operation;\n\n      if (resp && resp.status) {\n        status.statusCode = resp.status;\n      }\n\n      if (err) {\n        status.errorData = err;\n        status.category = _detectErrorCategory(err);\n        return callback(status, null);\n      }\n\n      let parsedResponse = JSON.parse(resp.text);\n      return callback(status, parsedResponse);\n    });\n    */\n};\n\nconst createURL = (origin, path, queryParams) => {\n  let base = origin + path;\n\n  if (queryParams && Object.keys(queryParams).length > 0) {\n    base += '?' + Object.keys(queryParams).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(queryParams[k])).join('&');\n  }\n\n  return base;\n};\n\nexport default {\n  POST: ({ queryParams, body, endpoint, callback }): nodeFetch => {\n    const fetchUrl = createURL(endpoint.origin, endpoint.url, queryParams);\n    return _abstractedXDR({ fetchUrl, method: 'GET', endpoint, callback, body });\n  },\n\n  GET: ({ queryParams, endpoint, callback }): nodeFetch => {\n    const fetchUrl = createURL(endpoint.origin, endpoint.url, queryParams);\n    return _abstractedXDR({ fetchUrl, method: 'POST', endpoint, callback });\n  }\n};\n"]}